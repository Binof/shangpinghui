1.静态页面书写
2.cli搭建环境
3.静态组件的拆分
4.路由器注册：
  1.router文件引入VueRouter 创建router对象
  2.在主页入口文档中引入路由器并注册
  3.注册完路由后所有组件将会拥有一个$route、$router 属性
5.路由与路由配置：
  在router下的index下router对象中配置路由属性routers:[每一组路由为对象形式{path：路径，components：组件名}] 
    5.1总结：路由组件与非路由组件的区别？
      1.路由组件一般放在pages|views文件夹，静态组件一般放在components文件夹下
      2.路由组件需要在router（路由器）文件中进行注册（注册一般见名知意），使用时通过router提供的路由入口标签使用
        静态组件一般时都是在父组件中注册，使用时通过组件标签使用
    5.2路由跳转方式：
      1.声明式导航 router-link ,可以进行路由跳转
      2.编程式导航 push | replace ,可以进行路由跳转

      编程式导航：声明式导航能做的，它也能做
      声明式导航只能单纯跳转路由，编程式导航还可以做一些其他的业务处理

6.footer组件的显示与隐藏
  显示或者隐藏添加属性：v-if||v-show
  footer组件：在home、search页面时显示
  在登录、注册页面时隐藏

  6.1我们可以通过当前页面的$route.path属性来决定显隐
  也可以通过路由元信息（meta）属性设置一个show属性来决定
7.路由传参

  7.2路由传参，参数有几种？
    params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
    query参数：不属于路径中的一部分，类似于ajax中的quertString /home?k=v&k=v 不需要占位


      //面试1：对象写法的路由传参方式path是否可以结合params使用？
      //不可以，query方式可以，但params必须是name
      //面试2：如可指定params参数可传可不传？
      //如果路由器配置路径时加了占位符，这组件路由传参没有配置params那么我们路由Url就会出现问题
      //解决方式:在路由器配置占位符时后面加个？即可
      //面试3: params参数可以传递也可以不传递，如果传递的是空字符串，如何解决？
      //使用undefined解决：
      this.$router.push({name:'search'},params:{keyword:''||undefined},query:{
        K=this.keyword.toUpperCase()
      })
      //面试4：路由组件可不可以传递props参数？？
      可以传递：
      1.props:布尔值写法》只能传递params参数

8.三级组件完成
  ---由于三级联动，在Home\search\detail,把三级联动组件注册为全局组件
  好处：只需要注册一次，就可以在项目任何地方使用
9.axios二次封装

  为啥要二次封装？为了配置请求拦截和响应拦截，请求之前可以做一些业务；响应拦截器，当服务器数据返回后，可以处理一些事情
  
  我们经常创建一个APi文件夹来放置axios

  9.1跨域问题：jsonp cors 代理服务器

10.进度条nprogress
  引入插件并在请求拦截器和响应拦截器当中设置开始结束属性的调用


11.vuex状态管理库
  集中式管理组件状态的插件，提供一个store库集中式管理公共数据
  项目小巧，且数据不多，组件间通信简单，可不用vuex，
  项目大，数据多，组件成分复杂可以使用vuex
  
  vuex模块化
    //模块化vuex引入模块
    import home from './home'
    import search from "./search";
    //创建并暴露vuex.store实例 

    export default new Vuex.Store({
      modules:{
        home,search
      }
    })
  

12.三级联动组件数据获取并展示
    数据结构分析：
    {
      name:一级分类
      id:1
      chlid:[
        {
          name:二级分类
          id:1
          chlid:[
            {
              name:三级级分类
              id:1
            },
            {
              name:三级级分类
              id:2
            },
            {
              name:三级级分类
              id:2
            },
          ]
        },
         {
          name:二级分类
          id:2
          chlid:[
            {
              name:三级级分类
              id:1
            },
            {
              name:三级级分类
              id:2
            },
            {
              name:三级级分类
              id:2
            },
          ]
        },
      ]
    },
    //

13.完成一级列表的经过效果
  1.第一种解决方案直接样式添加
  2.通过js来完成效果：
    1.在data中添加一个数据（currentIndex）来存储当前鼠标所在元素的索引值：
    2.在需要实现效果的元素上面监听鼠标事件调用方法
    3.在method中去配置方法：拿到当前元素的索引值，并将他赋值给data中的currentIndex
    4.元素标签动态绑定样式类名：当索引值和data中的currentIndex值相等时当前元素存在当前配置的样式类

14.完成二级列表的显示隐藏效果
    1.通过样式display来控制元素显隐
    2.通过js来完成效果：目标元素标签动态绑定样式属性：当索引值和data中的currentIndex值相等时display为block，其余的为none
  
15.卡顿现象解决（防抖，节流）
  节流：事件触发之后规定在一定时间之后才能再次触发，只有大于这个事件间隔才能触发回调，将频繁触发变为少量触发

  防抖：前面所有的触发都取消，最后一次执行在规定时间之后才会触发，也就是说如果连续快速的触发只会执行一次
  15.1三级联动需要节流
16.三级联动的路由跳转与传递参数
  使用编程式导航，事件委派：
  有如下问题需要解决：
      //1.事件委派：不知道点击的是不是a标签，他会委派给所有的子节点标签
      //2.点击a标签的时候，才会进行路由跳转
      //3.点击的是几级标签也需要确定

      //1.把a标签加上自定义标签
      //获取到当前触发这个事件的节点
      let element = event.target;
      //通过dataset属性，可以获取节点的自定义属性与属性值
      //解构赋值获取对应的自定义属性

17.搞定搜索组件里面的typeNav组件(有个过渡动画)
  过渡动画前提：元素|组件必须有v-if|v-show

18.性能与优化：
  我们发现每次路由跳转时都会发起数据请求很影响性能
  所以将请求不要配置在TypeNav组件挂载完成之后，配置在APP组件挂载完成之后

19.合并params和query参数

20.首页中ListContainer组件与floor组件
  我们目前使用的服务器没有提供ListContainer和floor组件的数据，
  mockjs插件的使用：模拟数据本机使用不会与后端交互
  1.在src中创建一个mock文件夹（提供假数据）
  2.准备json数据
  3.把json中需要的图片放在public下后面打包的时候会将图片原封不动的放在dist文件夹下面

21.listcontainer组件开发
    安装swiperc插件
    21.1解决轮播图效果实现：
      1.添加一个定时器延时实例化达到效果
      2.watch+nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
        保证的是数据更新之后dom 能够及时渲染
22.开发floor组件
    22.1 getfloorlist这个action在哪里触发？观察解构发现应该在home组件主页下触发
    因为有两个floor组件都需要数据
    22.2v-for属性可以用在组件标签中
    22.3回忆组件间有哪些通信方式？
     (1)事件总线通过在Vue.prototype属性上添加一个bus属性
     （2）props:用于父子组件之间
     （3）自定义事件：￥on，$emit可是实现子给父亲通信
      （4）事件的订阅预发布pubsub
      （5）插槽的使用
      （6）vuex

23.search模块开发
  流程：静态页面+静态组件拆分出来
  发请求
  vuex（三连环）
  组件获取vuex库中数据，动态展示数据
  //通过监视路劲变化来控制发请求,注意在每一次请求之前记得滞空请求参数的三个id
  //后面有很多小逻辑在其中如：面包屑模块的增删，每次操作更改了searchParams中的参数时记得再次调用发送请求的方法
/****************************/


  小难点：商品排序功能的实现
  排序规则由请求参数的属性order决定
  排序方式 
    1: 综合,2: 价格 asc是升序,desc是降序
    示例: "1:desc"
    1.1第一步：考虑点击的标签样式（动态类名）
      可以通过参数order属性中包含的是1（综合）还是2（价格）来判断
      动态绑定iconfont图标的类名，
      绑定点击事件来判断用户点击的那个标签（传入参数综合传1价格传2）
      事件方法接收参数；存储当前状态的order数据
      创建新的变量存储整理点击后状态的order数据：

      更新数据后发起请求

24 分页器的功能
    需要知道当前在那一页：pageon
    需要知道每一页有多少条数据:pagesize
    需要知道真个分页器一共有多少页取决于有多少条数据：页数=总数/每页的条数:total
    需要知道连续的页码数:continues

25 详情页面的完善
    1.静态组件
    2.发请求
    3.vuex(三连发)
    4.动态展示组件

26 加入购物车成功失败模块
  这里我们需要带数据向服务器请求之后看是否成功，服务器也没有返回数据
  所以我们不需要存储vuex仓库
27 购物车页面
  27.1静态组件
  27.2向服务器发起请求，获取购物车数据，配置vuex，组件获取数据，展示数据
  这里我们发现购物车无法获取到商品数据，我们需要配置一个游客身份验证的token
  3.3游客身份通过uuid库生成
  3.4动态展示购物车：
    服务器返回的数据格式不是很完美


28注册登录组件的完成
  登录注册功能（git）：必须掌握
  1.1静态组件完成就
  1.2assets文件夹---放置公共静态资源
  1.3css中使用src快捷路径在@前面加~
    2注册业务
    2.1注册业务 | 登录业务中表单验证先不做处理


  登录业务
  5.1注册---通过数据库存储的用户信息名字密码
  5.1登录---登陆成功的时候，后台为了区分你这个用户是谁，服务器下发token（令牌：唯一标识）
    一般登陆成功服务器会下发token ，前台持久化存储token(locastorge,vuex),（后面的请求都会携带这token后台做验证）

  token令牌理解“一个特殊的字符串，用于验证身份”
  注意：vuex存储不是持久化的，刷新后会有一些数据消失

29登录后用户信息展示
  当用户完成注册,登录向服务器发送请求（组件派发action：userLogin发起请求）,
  登录成功后服务器返回token,将其存储在vuex中,跳转到首页,首页头部展示用户信息
  
  
  当我们刷新页面时会发现token值消失且,登录状态退出
  原因:vuex是非持久化存储,刷新时会丢失数据

  当前存在的问题:
      多个组件要展示用户信息要在每个组件mounte阶段获取用户信息
      //获取用户登录信息
      this.$store.dispatch("getUserInfo");
      用户已经登录之后就不应该能回登录页了(路由守卫)

      路由守卫:某些状态下不能路由到一些页面
  <!-- 全局守卫:
    前置路由守卫:当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。
    
    后置路由守卫:路由跳转后执行的回调
  路由独享守卫:
    每个组件单独的设置的路由守卫 -->

  此次路由守卫逻辑:
    1.首先判断是否登录(通过vuex中的token值),未登录直接next()(游客身份状态,这里面还有很多逻辑没有处理)
    2.有token判断用户的导航地址,此时登录状态不能跳转到登录和注册页,所以我们进行导航拦截(重定向到首页)
    3.目标路由不是登录或者注册,开始判断是否有用户信息,有则正常跳转,没有我们通过派发action去获取用户信息,然后进行路由跳转
      (注意:这里如果每次跳转执行到第三条逻辑那么都将会获取用户信息经行展示,我们就可以省去每次跳转组件时都需获取一次用户信息)
    4.第三步如果没能成功获取到用户信息说明用户的登录异常(比如token过期),此时派发action将用户退出登录,自动跳转到登录页,重新登录获取token值
    


  elementUi组件库的使用参考官网教程
  